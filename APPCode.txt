import os
import pickle
import pandas as pd
import numpy as np
from flask import Flask, render_template, request, jsonify
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.feature_selection import SelectFromModel
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, BatchNormalization
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping

app = Flask(__name__)

# ==================== DATA SOURCES ====================

URLS = {
    'premier': [
        'https://www.football-data.co.uk/mmz4281/2425/E0.csv',  # 2024/2025
        'https://www.football-data.co.uk/mmz4281/2324/E0.csv',  # 2023/2024
        'https://www.football-data.co.uk/mmz4281/2223/E0.csv',  # 2022/2023
        'https://www.football-data.co.uk/mmz4281/2122/E0.csv',  # 2021/2022
        'https://www.football-data.co.uk/mmz4281/2021/E0.csv'   # 2020/2021
    ],
    'championship': [
        'https://www.football-data.co.uk/mmz4281/2425/E1.csv',  # 2024/2025
        'https://www.football-data.co.uk/mmz4281/2324/E1.csv',  # 2023/2024
        'https://www.football-data.co.uk/mmz4281/2223/E1.csv',  # 2022/2023
        'https://www.football-data.co.uk/mmz4281/2122/E1.csv',  # 2021/2022
        'https://www.football-data.co.uk/mmz4281/2021/E1.csv'   # 2020/2021
    ]
}

# ==================== DATA LOADING AND PREPROCESSING ====================

def load_data(urls):
    """Load data from multiple URLs and combine into single DataFrame"""
    all_data = []
    
    for league, league_urls in urls.items():
        for url in league_urls:
            try:
                df = pd.read_csv(url)
                df['League'] = league  # Add league identifier
                all_data.append(df)
                print(f"Successfully loaded data from {url}")
            except Exception as e:
                print(f"Error loading data from {url}: {str(e)}")
    
    if not all_data:
        raise Exception("No data could be loaded from any source")
    
    combined_df = pd.concat(all_data, ignore_index=True)
    return combined_df

def preprocess_data(df):
    """Preprocess the raw data"""
    # Select only columns we need
    essential_cols = ['Date', 'HomeTeam', 'AwayTeam', 'FTHG', 'FTAG', 'FTR', 'HS', 'AS', 'HST', 'AST', 'HC', 'AC', 'HF', 'AF', 'HY', 'AY', 'HR', 'AR', 'League']
    available_cols = [col for col in essential_cols if col in df.columns]
    df = df[available_cols]
    
    # Handle missing values
    df.fillna(0, inplace=True)
    
    # Convert categorical columns
    categorical_cols = ['HomeTeam', 'AwayTeam', 'FTR', 'League']
    for col in categorical_cols:
        if col in df.columns:
            df[col] = df[col].astype('category')
    
    return df

def engineer_features(df):
    """Create features for modeling"""
    # Create team statistics
    team_stats = {}
    all_teams = pd.unique(pd.concat([df['HomeTeam'], df['AwayTeam']]))
    
    for team in all_teams:
        home_matches = df[df['HomeTeam'] == team]
        away_matches = df[df['AwayTeam'] == team]
        
        team_stats[team] = {
            'home_goals_scored': home_matches['FTHG'].mean(),
            'home_goals_conceded': home_matches['FTAG'].mean(),
            'home_shots': home_matches['HS'].mean() if 'HS' in df.columns else 0,
            'home_shots_target': home_matches['HST'].mean() if 'HST' in df.columns else 0,
            'home_corners': home_matches['HC'].mean() if 'HC' in df.columns else 0,
            
            'away_goals_scored': away_matches['FTAG'].mean(),
            'away_goals_conceded': away_matches['FTHG'].mean(),
            'away_shots': away_matches['AS'].mean() if 'AS' in df.columns else 0,
            'away_shots_target': away_matches['AST'].mean() if 'AST' in df.columns else 0,
            'away_corners': away_matches['AC'].mean() if 'AC' in df.columns else 0,
            
            'home_win_rate': (home_matches['FTR'] == 'H').mean(),
            'home_draw_rate': (home_matches['FTR'] == 'D').mean(),
            'away_win_rate': (away_matches['FTR'] == 'A').mean(),
            'away_draw_rate': (away_matches['FTR'] == 'D').mean(),
            
            'total_matches': len(home_matches) + len(away_matches)
        }
    
    # Create match features
    match_features = []
    labels = []
    
    for _, match in df.iterrows():
        home_team = match['HomeTeam']
        away_team = match['AwayTeam']
        
        if home_team not in team_stats or away_team not in team_stats:
            continue
        
        home_stats = team_stats[home_team]
        away_stats = team_stats[away_team]
        
        # Create feature vector
        features = [
            home_stats['home_goals_scored'],
            home_stats['home_goals_conceded'],
            home_stats['home_shots'],
            home_stats['home_shots_target'],
            home_stats['home_corners'],
            home_stats['home_win_rate'],
            home_stats['home_draw_rate'],
            
            away_stats['away_goals_scored'],
            away_stats['away_goals_conceded'],
            away_stats['away_shots'],
            away_stats['away_shots_target'],
            away_stats['away_corners'],
            away_stats['away_win_rate'],
            away_stats['away_draw_rate'],
            
            # Difference features
            home_stats['home_goals_scored'] - away_stats['away_goals_conceded'],
            away_stats['away_goals_scored'] - home_stats['home_goals_conceded'],
            
            # League indicator (1 for Premier, 0 for Championship)
            1 if match['League'] == 'premier' else 0
        ]
        
        match_features.append(features)
        labels.append(match['FTR'])
    
    X = np.array(match_features)
    y = np.array(labels)
    
    return X, y, team_stats

# ==================== MODEL TRAINING ====================

def train_random_forest(X, y):
    """Train a Random Forest model"""
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # Feature scaling
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    
    # Feature selection
    selector = SelectFromModel(RandomForestClassifier(n_estimators=100))
    selector.fit(X_train_scaled, y_train)
    X_train_selected = selector.transform(X_train_scaled)
    X_test_selected = selector.transform(X_test_scaled)
    
    # Train model
    model = RandomForestClassifier(n_estimators=200, random_state=42)
    model.fit(X_train_selected, y_train)
    
    # Evaluate
    accuracy = model.score(X_test_selected, y_test)
    print(f"Random Forest Accuracy: {accuracy:.4f}")
    
    return {
        'model': model,
        'scaler': scaler,
        'selector': selector,
        'accuracy': accuracy
    }

def train_neural_network(X, y):
    """Train a Neural Network model"""
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # Encode labels
    label_encoder = LabelEncoder()
    y_train_encoded = label_encoder.fit_transform(y_train)
    y_test_encoded = label_encoder.transform(y_test)
    
    # Feature scaling
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)
    
    # Feature selection
    selector = SelectFromModel(RandomForestClassifier(n_estimators=100))
    selector.fit(X_train_scaled, y_train_encoded)
    X_train_selected = selector.transform(X_train_scaled)
    X_test_selected = selector.transform(X_test_scaled)
    
    # Build model
    model = Sequential([
        Dense(64, activation='relu', input_shape=(X_train_selected.shape[1],)),
        BatchNormalization(),
        Dropout(0.3),
        Dense(32, activation='relu'),
        Dense(len(label_encoder.classes_), activation='softmax')
    ])
    
    model.compile(optimizer=Adam(learning_rate=0.001),
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])
    
    # Train model
    early_stopping = EarlyStopping(patience=10, restore_best_weights=True)
    history = model.fit(X_train_selected, y_train_encoded,
                        validation_data=(X_test_selected, y_test_encoded),
                        epochs=100,
                        batch_size=32,
                        callbacks=[early_stopping],
                        verbose=0)
    
    # Evaluate
    _, accuracy = model.evaluate(X_test_selected, y_test_encoded, verbose=0)
    print(f"Neural Network Accuracy: {accuracy:.4f}")
    
    return {
        'model': model,
        'scaler': scaler,
        'selector': selector,
        'label_encoder': label_encoder,
        'accuracy': accuracy
    }

# ==================== PREDICTION FUNCTIONS ====================

def predict_match(home_team, away_team, model_type='rf'):
    """Make a prediction for a match"""
    global models, team_stats
    
    if home_team not in team_stats or away_team not in team_stats:
        return None
    
    home_stats = team_stats[home_team]
    away_stats = team_stats[away_team]
    
    # Create feature vector (must match training features exactly)
    features = [
        home_stats['home_goals_scored'],
        home_stats['home_goals_conceded'],
        home_stats['home_shots'],
        home_stats['home_shots_target'],
        home_stats['home_corners'],
        home_stats['home_win_rate'],
        home_stats['home_draw_rate'],
        
        away_stats['away_goals_scored'],
        away_stats['away_goals_conceded'],
        away_stats['away_shots'],
        away_stats['away_shots_target'],
        away_stats['away_corners'],
        away_stats['away_win_rate'],
        away_stats['away_draw_rate'],
        
        home_stats['home_goals_scored'] - away_stats['away_goals_conceded'],
        away_stats['away_goals_scored'] - home_stats['home_goals_conceded'],
        
        # Default to Premier League for prediction
        1
    ]
    
    features = np.array(features).reshape(1, -1)
    
    model_info = models[model_type]
    
    try:
        # Apply preprocessing
        features_scaled = model_info['scaler'].transform(features)
        features_selected = model_info['selector'].transform(features_scaled)
        
        # Make prediction
        if model_type == 'rf':
            prediction = model_info['model'].predict(features_selected)[0]
            probabilities = model_info['model'].predict_proba(features_selected)[0]
            classes = model_info['model'].classes_
        else:  # nn
            probabilities = model_info['model'].predict(features_selected, verbose=0)[0]
            prediction_idx = np.argmax(probabilities)
            prediction = model_info['label_encoder'].inverse_transform([prediction_idx])[0]
            classes = model_info['label_encoder'].classes_
        
        # Map outcome
        outcome_mapping = {
            'H': f"{home_team} win",
            'D': "Draw",
            'A': f"{away_team} win"
        }
        
        return {
            'prediction': outcome_mapping[prediction],
            'probabilities': {outcome_mapping[cls]: f"{prob:.1%}" for cls, prob in zip(classes, probabilities)},
            'model_type': 'Random Forest' if model_type == 'rf' else 'Neural Network'
        }
    except Exception as e:
        print(f"Prediction error: {str(e)}")
        return None

# ==================== FLASK ROUTES ====================

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        home_team = request.form.get('home_team')
        away_team = request.form.get('away_team')
        model_type = request.form.get('model_type', 'rf')
        
        result = predict_match(home_team, away_team, model_type)
        
        if result:
            return render_template('index.html',
                                teams=sorted(list(team_stats.keys())),
                                result=result,
                                home_team=home_team,
                                away_team=away_team,
                                model_type=model_type)
    
    return render_template('index.html',
                         teams=sorted(list(team_stats.keys())))

@app.route('/predict', methods=['POST'])
def predict():
    data = request.get_json()
    home_team = data.get('home_team')
    away_team = data.get('away_team')
    model_type = data.get('model_type', 'rf')
    
    if not home_team or not away_team:
        return jsonify({'error': 'Missing team names'}), 400
    
    result = predict_match(home_team, away_team, model_type)
    
    if not result:
        return jsonify({'error': 'Prediction failed - teams not found or model error'}), 400
    
    return jsonify(result)

# ==================== APPLICATION SETUP ====================

def initialize_application():
    global models, team_stats
    
    # Load and preprocess data
    print("Loading data from URLs...")
    df = load_data(URLS)
    print("Preprocessing data...")
    df = preprocess_data(df)
    print("Engineering features...")
    X, y, team_stats = engineer_features(df)
    
    # Train models
    print("Training Random Forest model...")
    rf_model = train_random_forest(X, y)
    print("Training Neural Network model...")
    nn_model = train_neural_network(X, y)
    
    models = {
        'rf': rf_model,
        'nn': nn_model
    }
    
    # Save models and stats for future use
    with open('model_data.pkl', 'wb') as f:
        pickle.dump({
            'models': models,
            'team_stats': team_stats
        }, f)
    print("Models trained and saved successfully")

# ==================== MAIN EXECUTION ====================

if __name__ == '__main__':
    # Create templates directory if it doesn't exist
    os.makedirs('templates', exist_ok=True)
    
    # Create basic HTML template
    with open('templates/index.html', 'w') as f:
        f.write('''
<!DOCTYPE html>
<html>
<head>
    <title>Football Match Predictor</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .form-container { background: #f9f9f9; padding: 20px; border-radius: 5px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; }
        select, button { width: 100%; padding: 8px; }
        button { background: #4CAF50; color: white; border: none; cursor: pointer; }
        .result { margin-top: 20px; padding: 15px; background: #e8f5e9; border-radius: 5px; }
        .probability-bar { height: 20px; background: #ddd; margin-top: 5px; }
        .probability-fill { height: 100%; background: #4CAF50; }
    </style>
</head>
<body>
    <h1>Football Match Predictor</h1>
    
    <div class="form-container">
        <form method="POST">
            <div class="form-group">
                <label for="home_team">Home Team:</label>
                <select id="home_team" name="home_team" required>
                    <option value="">Select Home Team</option>
                    {% for team in teams %}
                        <option value="{{ team }}" {% if home_team == team %}selected{% endif %}>{{ team }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <div class="form-group">
                <label for="away_team">Away Team:</label>
                <select id="away_team" name="away_team" required>
                    <option value="">Select Away Team</option>
                    {% for team in teams %}
                        <option value="{{ team }}" {% if away_team == team %}selected{% endif %}>{{ team }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <div class="form-group">
                <label for="model_type">Model Type:</label>
                <select id="model_type" name="model_type">
                    <option value="rf" {% if model_type == 'rf' %}selected{% endif %}>Random Forest</option>
                    <option value="nn" {% if model_type == 'nn' %}selected{% endif %}>Neural Network</option>
                </select>
            </div>
            
            <button type="submit">Predict Outcome</button>
        </form>
        
        {% if result %}
        <div class="result">
            <h2>Prediction: {{ home_team }} vs {{ away_team }}</h2>
            <p><strong>Result:</strong> {{ result.prediction }}</p>
            <p><strong>Model:</strong> {{ result.model_type }}</p>
            <h3>Probabilities:</h3>
            {% for outcome, prob in result.probabilities.items() %}
                <div>
                    <span>{{ outcome }}: {{ prob }}</span>
                    <div class="probability-bar">
                        <div class="probability-fill" style="width: {{ prob }}"></div>
                    </div>
                </div>
            {% endfor %}
        </div>
        {% endif %}
    </div>
</body>
</html>
''')
    
    # Initialize application data
    try:
        # Try to load pre-trained models
        with open('model_data.pkl', 'rb') as f:
            data = pickle.load(f)
            models = data['models']
            team_stats = data['team_stats']
        print("Loaded pre-trained models")
    except:
        print("No pre-trained models found, training new models...")
        initialize_application()
    
    # Run the app
    app.run(debug=True)